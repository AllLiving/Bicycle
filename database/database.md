<center>

### 2018年移动信息工程数据库课程实验报告

曹广杰 15352015， 蔡政 15352014， 张明华 14353396

授课教师：刘玉葆

2018/1/26

</center>

[TOC]

&emsp;&emsp;摘要：笔者团队在2017-2018年学期选择了刘玉葆老师的《数据库系统》课程，根据老师的要求需要对大作业进行选择与实现。笔者团队选择实现一篇数据挖掘的论文，这里实现的论文为出自上海交通大学的《Traffic Prediction in a Bike-Sharing System》，是一篇数据挖掘领域的论文，主要阐释了根据过去一年中各个站点的自行车的数据信息预测下一年的在各个站点的自行车分布数量的算法思想，整体思想是几种简单算法的综合。

关键词：数据挖掘、自行车站点预测

#### 实验概述

&emsp;&emsp;本文主要实现对各个站点共享单车在某一个时间段的变化情况进行预测，根据已有的过去时间段内的停靠信息，综合聚类算法、GBRT算法，结合损失函数的拟合思想对已有的自行车流动模型进行计算机建模，并凭借此模型预测未来一段时间内的共享单车流动信息。实验的源代码已经添加到GitHub上。[^1]

##### 实验整体流程

&emsp;&emsp;在笔者团队参照的论文《Traffic Prediction in a Bike-Sharing System》中，行文结构为：

1. 对所有站点进行站点聚类，此后都将基于已经实现的聚类进行算法实现(3.1)

2. 提出使用GBRT预测整体的预测方法(3.2)

3. 预测从站点离开的共享单车数量（或比例）(3.3)

   预测操作需要从不同的角度，考虑不同的因素（multi-similarity-based inference model）

4. 基于从站点离开的共享单车数量预测某一时间段进入该站点的共享单车数量，使用模型multi-similarity-based inference model(3.4)

5. 最大似然函数拟合预测trip duration(3.5)

而笔者实现的流程为

```flow
stt=>start: start
km=>operation: KMeans Cluster
Traffic Cluster
gbrt=>subroutine: 模块化实现
GBRT，3个角度
ls=>subroutine: 最小化损失函数
获得权值信息
构建GBRT模型
tm=>operation: 1. 时间似然函数
2. 温度与风速-
-似然函数
3. 天气似然函数
prt=>operation: 根据GBRT模型预测
end=>end: end

km->gbrt(right)->tm
tm(right)->ls->prt(right)
```

&emsp;&emsp;笔者的实现流程基本遵循原文的实现流程，只是在实现的细节上进行了改动，在不影响实验结果的前提下对实现的算法进行了修改和简化。从整体上分为三个部分：

1. 根据经纬度和交通流向信息对站点聚类；

   具体的聚类过程主要参照两个变量，使用了两种算法（KMeans聚类与交通流量聚类）。

2. 分析不同的特征值（即影响因素）用于构建模型；

   分为三个角度分析与构建：天气、温度与风速、时间。

3. 根据校正后的模型进行预测；

   使用上一步训练得到的模型，对该模型输入需要的信息（时间、天气、温度、经纬度等），经过模型的运算可以获得预测的信息。

##### 行文思路

&emsp;&emsp;本文将会对笔者团队已经实现的部分进行分析和解释，主要针对笔者使用的算法进行剖析，并对实现的细节举例阐释。

&emsp;&emsp;实现进展的部分将会以时间顺序展示笔者团队在不同时间段内所做的工作主题，实现详情部分将分层次对实验进行过程中的具体算法实现进行解释和分析，笔者将分析比较具体实现与原论文《Traffic Prediction in a Bike-Sharing System》的异同和优劣，而在其后的部分展示团队实现的阶段性成果，笔者会使用小数据集测试已经实现的算法部分，以图表的形式展现出较为直观的分析效果。改进方向模块将会描述一些已有的可解释性较强的算法，笔者会阐述其在解决该问题中的使用方法，作为下一步改进中可行性较高的实现方法。

#### 实现进展

|   时间   | 进度主题                  |
| :----: | --------------------- |
| 16周之前  | 数据处理与论文的阅读            |
| 16-17周 | KMeans聚类              |
| 17-18周 | 站点间流向信息聚类             |
| 18-19周 | 实现GBRT的时间似然、气温与风速似然部分 |
| 19-20周 | 期末考试                  |
| 20-21周 | 将已经实现的模块进行整合          |

#### 算法实现

&emsp;&emsp;该章节会细致阐释已经实现的算法细节以及算法的设计原理。将主要应对两个问题，聚类和似然函数的拟合，会细致解释KMeans聚类算法、T聚类算法、时间似然函数和气温和风速的似然。

##### 站点聚类

&emsp;&emsp;首先需要明确一点，**对于站点的聚类是必要的，而针对每一个站点进行分析是不必要的。**因为：

1. 使用者可能会将单车停靠在靠近其目的地的任意一个站点内，此中的随机性比较大；
2. 即使某站点内没有可用的车辆，用户也会选择附近站点的车辆，这就使得站点之间的车辆数量具有非常明显的补偿关系；
3. 其他因素的（自然因素或人为因素）影响范围往往是一片区域而非某个站点；

因此，在下文的站点聚类中，需要考虑的因素为地理位置（经纬度）和站点之间的流量信息。

###### 聚类模块整合

综合的站点聚类：

Input：各个站点的位置$\{S_i\}^n_{i=1}$，各个站点的流向信息$\{T_i\}^n_{i=1}$，迭代阈值K；

Output：需要的K1个聚类中心$\{C_i\}^n_{i=1}$；  

```c++
  initialize k=0
  while k<K do{
    // Kmeans cluster
    Cluster S into K1 clusters;
    // Traffic cluster
    for s_=1:n do{
      if go to same Cluster
        push into one cluster;
    }
	Update Cluster S;
  }
```

1. 首先根据地理位置，根据经纬度进行聚类，此时指定聚类的数量为K1，在聚类的时候进使用KMeans聚类算法。KMeans聚类之后会返回K1个聚类的中心点，这些中心点坐标是仅仅考虑地理位置的坐标。
2. 对K1个聚类中心点继续进行KMeans聚类，指定聚类的数量为K2；
3. Traffic聚类将根据每一个站点的终点站进行聚类，选择终点站处于相同聚类的站点作为一类，如此得到具有相同交通流向的K2个站点聚类，聚类中的站点数量分别为$N_1, N_2, N_3, ..., N_{K_2}$；
4. 对Traffic的每一个聚类再次进行KMeans聚类，聚类的数量为$[\frac{N_1K_1}{n}],[\frac{N_2K_1}{n}], ..., [\frac{N_{K_2}K_1}{n}]$，直到聚类的结果稳定或者迭代的次数足够多为止；

###### Traffic聚类算法

&emsp;&emsp;T聚类算法即根据交通信息进行聚类的算法，基于KMeans聚类的基础上将聚类的实现添加交通流量的考虑因素进行聚类，保证聚类的结果更加符合实际的需求。

&emsp;&emsp;在实际的实现中，交通聚类算法主要针对每一个独立的站点（而非聚类）考虑流量信息，即每一个站点的交通向另一个站点聚类的流量，以期望通过交通流量信息得到一种聚类的结果。以下是对于目的地为M聚类的站点的聚类流程图：

```flow
io=>inputoutput: 行程记录
data=>operation: 读取下一条
行程记录
cond=>condition: 终点站是否属于聚类M
log=>operation: 起始站
添加到聚类
end=>inputoutput: 终点为M聚类
的起始点聚类

io(right)->data->cond
cond(yes)->log
cond(no,right)->data
log(right)->end
```

交通流量导向的聚类算法：

&emsp;&emsp;输入为所有行车记录的起屹点，输出为流向聚类M中的点的坐标集合N（新的聚类）。

1. 对输入的每一条数据读取终点坐标；
2. 如果行程记录的目的地属于聚类M，则忽略；
3. 如果行程记录的目的地属于聚类M，则将该记录的起始点添加到聚类N中；
4. 重复1-3直至完成所有数据的筛选；

&emsp;&emsp;以上算法可以重复应用在KMeans得到的每一个聚类中，最终获得$K_2$个交通流向主导的聚类结果。这种设计主要为了弥补KMeans聚类中仅考虑位置因素而没有考虑交通流量因素的缺陷，在交通聚类算法中，会根据站点的交通流向对所有的站点重新聚类，这种聚类方式将目的地位置相近的站点聚类到一起，则将交通流向描述为具有集中性质的行程记录从一个聚类转移到另一个聚类，于是收敛后聚类的结果即为已有行程记录的几个重要的交通区域，突出强调了交通流向的作用。

###### Traffic聚类与KMeans聚类

&emsp;&emsp;Traffic聚类需要依赖于KMeans聚类。因为Traffic聚类所返回的聚类结果是聚类中点的集合，而不是其中的聚类中心。至于从该聚类中根据已有的坐标点集合获取聚类中心的工作，则交由KMeans聚类进行处理。

&emsp;&emsp;Traffic算法这样的设计是因为Traffic无需理解聚类中心的意义，Traffic算法的主要意义是找出具有相同流向的站点的集合，至于在一个站点坐标的集合中如何获取一个中心是有许多种方法的，但是计算中心与交通的流向关系不大，所以此处完全可以使用已有的任何现有的算法计算坐标集合的中心点。

&emsp;&emsp;Traffic聚类之后返回的坐标集合正是KMeans聚类的需要的参数，KMeans在Traffic聚类的基础上聚类的中心数量是$[\frac{N_1K_1}{n}],[\frac{N_2K_1}{n}], ..., [\frac{N_{K_2}K_1}{n}]$，即根据聚类中的站点数量进行聚类数量的选择，尽量使得各个聚类中所拥有的站点数量平均：
$$
某聚类的中心数量=期望的聚类中心总数\times\frac{该聚类中的站点数量}{站点总数}
$$
站点数量平均的指标在一定程度上削弱了噪声点对于聚类的影响，同时保证了两个相邻聚类中内部站点的密集度。

###### 比较论文中交通聚类

&emsp;&emsp;笔者的具体实现与《Traffic Prediction in a Bike-Sharing System》中的聚类方法是有一些出入的。KMeans算法没有什么区别，但是根据交通流量信息进行的聚类算法是有所不同的。

&emsp;&emsp;原文中依据交通聚类的算法如下：

1. 获取KMeans聚类得到的聚类结果；

2. 对每一个站点计算一个t矩阵：

   T矩阵有7行，对应7个时间段，即工作日的7:00am-11:00am、11:00am-4:00pm、4:00pm-9:00pm 、9:00pm-7:00am，双休日的00:00am-9:00am、9:00am-7:00pm、7:00pm-12:00pm；

   T矩阵有$K_1$列，分别表示当前时间段到达每一个聚类的可能性；

   综上，对于T矩阵中的每一个元素$(A_i)_{l,j}$，表示在时间段l，从当前站点i，到站点j的可能性。

3. 根据上文中的T矩阵，对起始站点聚为$K_2$个类；

&emsp;&emsp;相比于笔者实现的算法，原文中的算法考虑的信息更加丰富除了流量信息之外还包括了时间，并且使用可能性来描述某一个站点向其他站点聚类的流量。但是笔者并没有使用原文中的算法，原因如下：

1. 原文中使用可能性来描述从一个站点向其他站点的流向。

   &emsp;&emsp;使用可能性描述流向的优势是对交通流量的刻画更加细致，而笔者的实际实现中则直接使用计数的方法，也就是对于重复出现的站点依然纳入考虑，这种操作得到的统计结果也会由于重复站点出现频率的不同而造成对交通流量的描述不同，同时省略了通过频率模拟概率中复杂的浮点数运算；

2. 原文中建立每一个站点的描述矩阵时，考虑了时间因素。

   &emsp;&emsp;笔者的具体实现中没有考虑时间的因素，这种省略的直接结果就是将每一个站点的矩阵描述缩略为一个描述向量，这种省略会减少算法的时间复杂度与空间复杂度、突出强调交通流量的重要性。

   &emsp;&emsp;同时，由于交通聚类的返回聚类的结果时表示的是站点坐标的集合或者站点坐标聚类的中心，所以其实还是关注点还是站点的坐标，使用原文的T矩阵筛选时，需要同时考虑时间和流动可能性，一定会造成大量的信息丢失（而且原文并没有说明究竟是使用了什么方法根据T矩阵获得交通聚类的结果），而笔者的实现则直接使用整体流量信息作为衡量指标。从这一点上，二者只是筛选指标的不同而已。

###### 站点聚类的结果分析

&emsp;&emsp;这里随机选取一些点作为测试聚类效果的小数据集，其位置展示如下：

<img src="https://imgsa.baidu.com/forum/pic/item/d938acdde71190efc3eb811ac51b9d16fcfa60f4.jpg" />

&emsp;&emsp;右上角的聚类结果是仅使用KMeans的聚类效果，而右下角的聚类结果是综合了以上两种聚类方式实现的聚类结果，可以看到，由于一些站点的流量数据差距较大，在使用交通聚类中，仅有8个聚类中心（删除了两个噪音点），同时因为一些站点的流量较大，聚类的中心点也发生了转移，有向左下角转移的趋势。

##### GBRT模型权值构建

&emsp;&emsp;GBRT模型的构建用于拟合对于预测结果会有影响的其他特征值，通过GBRT对于各种特征属性的拟合，预测的指标会更为综合和全面，而预测的结果也会更为客观可信。
$$
\begin{align}
\hat P_t &= \frac{
  \sum_{i=1}^H w(f_i, f_t) \times P_i
}
{
  \sum_{i=1}^H w(f_i, f_t)
}
\end{align}
$$
其中$i=1, 2, 3, ..., H$表示距离当前时间的几个时间段，t则表示当前的时间信息；

$f_t$表示当前时间信息下的各种属性的值，同时$f_i$表示过去某一个时间内的影响车辆数量预测的属性的值；

$P_i$表示过去第i个时间段中车辆流动的数量（或者占车辆总数的比例）；

&emsp;&emsp;所以上式的计算目的就是根据过去时间内的车辆流动以及属性信息，预测当前t时间的车辆流动信息。现在该式中只有一个参数尚未明确，就是$w$，即权值参数。权值参数的设计是为了使过去不同时刻的车辆流动信息对当前的预测有不同的影响，削弱一些属性值相差较大（即不一致情况下）的流动数值的影响，同时增强一些属性值接近（即相近相似情况下）流动信息的影响。这种权值对于预测值的控制使得预测的结果更加准确，也更加符合实际。

&emsp;&emsp;依据原文中的实现，权值信息将会主要考虑三个参数天气、时间以及气温和风速信息。于是对于权值函数的描述为：
$$
\begin{align}
W(f_i, f_t) &= \lambda _1(i, t)
\times \lambda _2(w_i, w_t)
\times K(
	(p_i, v_i), (p_t, v_t)
)
\end{align}
$$
其中$\lambda _1$是描述时间的似然函数，$\lambda _2$是天气似然函数，$K$是气温和风速似然函数，以下的章节将会分别对其进行分析，并阐述具体的实现。

###### 权值的控制

&emsp;&emsp;权值对于最后的预测自然是有很大的影响，但是权值信息的控制也需要考虑，即符合什么情况的权值更为合理，如何才能筛选到最佳的权值序列。这里使用针对训练集的损失函数描述权值序列的合理性：
$$
\begin{align}
min_w\sum_{t=H+1}^TL(E_t\times P_t, E_t \times \hat {P_t})
\end{align}
$$
&emsp;&emsp;上式的主要思想是计算在验证集上预测的值与实际值的差距。所谓验证集是在提供的数据之外的，尚未使用的数据。在验证集上的预测结果实际上就是对于预测的一种检验，这里希望最小化在验证集上的误差值，此时的权值序列最符合预期的状态。

###### 时间似然函数

&emsp;&emsp;时间似然函数为本章开始部分的$\lambda _1$函数，$\lambda _1$函数考虑三种信息：是否为工作日、是否为同一天以及为同一个时间段。
$$
\begin{align}
\lambda _1 &= 1_{t_1, t_2}
\times \rho _1^{\Delta h(t_1, t_2)}
\times \rho _2^{\Delta d(t_1, t_2)}
\end{align}
$$

1. `1`表示冲激函数：

   - 如果$t_1$与$t_2$同时属于工作日则冲激函数为1；
   - 如果$t_1$与$t_2$同属周末则冲激函数为1；
   - 其他情况置为0；

   故而该函数用于划分当前参数是否是同一种情况。

2. 函数$\Delta h(t_1, t_2)$与$\Delta d(t_1, t_2)$。

   这里引入一个函数：
   $$
      r(t_1, t_2) = mod(|t_1 - t_2|, 24)
   $$
   &emsp;&emsp;该函数使用取模操作，比较差值的余数值，其实就是解释两个时间段相距的多少小时，是否是同一个时间段。

   函数$\Delta h(t_1, t_2)$：
   $$
   \Delta h(t_1, t_2) = min\{ 
      	r(t_1, t_2),
      	24 - r(t_1, t_2)
      \}
   $$
   &emsp;&emsp;操作记录了两个时间点在表盘上的时差，时差越大表明这两个时间点不是同一个时间段，参考价值越低。

   &emsp;&emsp;以上函数中的项$\rho^{\Delta h(t_1, t_2)}$应该是减函数。 

   函数$\Delta d(t_1, t_2)$： 
   $$
   \begin{align}
        \Delta d(t_1, t_2) &= 
        \left[ \frac{|t_1-t_2|}{24}
        \right]
      \end{align}
   $$
   同理应该使$\rho_{2}^{\Delta d(t_1, t_2)}$为减函数。

&emsp;&emsp;最后时间似然函数会根据传入的时间信息返回一个参考值，该值表示了当前时间信息对应的车辆流向的参考度，参考度越高，该流量信息对应的权值越高，对最后的预测结果影响越大。

###### 天气似然函数

&emsp;&emsp;天气似然函数主要对应本章开始的$\lambda _2$函数，主要是用于衡量当前的天气信息与之前某一个时刻中的天气信息是否相似，或者关联性大不大。如果两种天气状态极为相似，那么这种情况下，参与对比的前一个流动数据的参考性较大，否则较小。其实天气似然函数的拟合可以使用更加精细的模型，但是因为数据集中的数据有大量的缺失，使用精细的模型拟合，拟合的效果怕是也不尽如人意。

&emsp;&emsp;使用天气因素进行预测需要考虑以下前提：

- 前提一：天气因素有四种

- 前提二：不同时段的天气是有关系的

- 前提三：不同天气出现的概率可以由频率预测

因此在根据过去数据进行预测的时候需要遵循以下规则：

|      | 雪    | 雨    | 雾    | 晴    |
| ---- | ---- | ---- | ---- | ---- |
| 雪    | 1    | a1   | a2   | a3   |
| 雨    |      | 1    | a4   | a5   |
| 雾    |      |      | 1    | a6   |
| 晴    |      |      |      | 1    |

可以凭借此矩阵根据天气情况确定权值，该权值将会用于预测当前的车辆流量。

1. 允许没有记录的天气信息。

   因为实际上有一些天气信息是没有记录的，那么对于聚类中的计算而言，该部分信息是可以被其他时段的信息所代替表示的。

   也就是说，即使没有早6点的数据，使用晚6点的数据代替亦可。

2. 一天可能有多种天气。

   此时权值就根据一天中的多种天气综合考虑，返回矩阵中的值a1 a2 a3 a4 a5 或者 a6。

3. 计算权值信息

   填充矩阵中的值，即计算两种天气同时出现的频率。需要对两个数据集DC和NYC分别进行计算，计算的频率一定处于[0, 1]中，将计算得到的数据归一化，填入表格即可。

4. 检验结果与调整

   该矩阵中的变量遵循以下原则，请务必使其符合以下原则，允许适当的修改与数学模型的套用：
   $$
   a_1>a_2>a_3;\\
   a_4>a_5;\\
   a_6>a_5>a_3;\\
   a_4>a_2;
   $$


###### 气温和风速似然

&emsp;&emsp;气温和风速似然函数为本章开始部分的$\lambda _3$函数，气温和风速似然函数则考虑气温和风速信息，一般来讲，这两种因素与之前某一个时间段的情况同时出现的可能性越高，则该信息越具有参考意义。

&emsp;&emsp;在气温和风速似然函数中使用的主要方法是有两个参量的高斯函数，因为原始数据集中对于该部分的参数有大量的缺失。

高斯公式：
$$
\begin{align}
K((p_{t_1}, v_{t_1}), (p_{t_2}, v_{t_2})) &=
\frac{1}{2\pi\sigma_1\sigma_2}
e^
{-(\frac{
  (p_{t_1}-p_{t_2})^2
}{\sigma_1}
+ \frac{
  (v_{t_1}-v_{t_2})^2
}{\sigma_2}
)}
\end{align}
$$
&emsp;&emsp;高斯公式的前提是气温和风速因素符合高斯分布，即分布的频率与强度大致呈钟形曲线，极端值较少，大多数的值都处于中间的位置。恰好气温信息与风速信息都是符合此类分布的连续值，因此这里使用高斯分布来预测可能会出现的缺失值。传入的参数分别表示气温因素和风速因素，返回的值就是出现这种情况的可能性。同样的筛选方式，选择情况与当前条件更为相似的站点流量信息，增大其权值。

###### *使用命名空间实现气温和风速似然函数*

在气温和风速似然函数部分，为了实现似然函数，有三种策略。

- 第一种策略是创建一个类，在类中使用接口来完成公式的调用，但是公式只可能会直接使用，创建对象反而会变得非常繁琐使用这个函数时则会显得不雅观。
- 另一种策略则是直接定义一个函数，但是同时需要考虑几个参数的传入，但是在C++中自定义的函数又会破坏整个工程的逻辑架构。对于函数的名字而言，需要考虑Gause函数的重名问题，不谨慎地更改函数名又会降低代码的可读性。
- 第三种策略是使用命名空间在不改变函数的原名的情况下，将其封装起来，使用命名空间封装函数，可以同时保证函数的名称含义和代码的可读性和封装性。

&emsp;&emsp;这里实现中使用的是第三种策略，即通过命名空间的方式对自定义的函数进一步封装，以获得更体系化的层次结构。

#### 改进方向

&emsp;&emsp;该项目的实现历时半个学期，都是用一些零碎的时间进行的实现，在实现的过程中有一些不甚明了的地方，都将其修改为自定义的可行性方案，本节将会总结已经实现的改进方案以及尚未完成的可行性方案，并详细阐述实现的方法。

##### 根据交通聚类

&emsp;&emsp;根据交通聚类的实现是在聚类部分已经完成的实现，该部分实现笔者将原文中对每一个站点聚类时的衡量指标从多个参数修改为流量参数。

##### 密度聚类方法（DBSCAN）

&emsp;&emsp;在站点聚类的章节，聚类的主要算法是KMeans算法，KMeans算法是较为基础的启发式聚类算法，这种算法主要是根据初始化的聚类中心，根据各个点的距离信息进行聚类，并实现聚类中心的更迭。配合根据交通流量的聚类算法之后，通过交通流向的筛选，可以很大程度上消除噪音点，均衡聚类效果。

###### KMeans与Traffic聚类

&emsp;&emsp;因为KMeans聚类各个类别的主要判断依据是距离，即可能存在这样一种聚类情况：有零星的几个站点远离其他站点的密集区，但是这几个站点的数量不足其他聚类中站点的数量多，交通的流量也不及其他几个站点的流量密集。就是因为这几个站点与密集区的距离较远，就占用了一个聚类的数量（KMeans中聚类的数量被限定为常数）。这种分类方式很显然是不可取的。

<img width="390" src="https://imgsa.baidu.com/forum/pic/item/67cad63df8dcd100ad9b30e5798b4710b8122ff8.jpg" />

&emsp;&emsp;上图中的各个点表示聚类中心，聚类中心X表示的聚类中站点数量和流量都非常少，但是由于距离密集区（第一象限）较远而被单独划分为一个聚类。但是该站点的交通流量较少，故而不能很好地反映出整体的交通走向，X聚类可以看做当前聚类状态的噪音点，所以这种聚类方式是不符合期望的。

&emsp;&emsp;在加入Traffic聚类的考虑之后，站点之间的交通流量信息成为衡量的主要标准，此时聚类中心X所在的聚类就没有单独成为一个聚类的资格，于是其中的站点被划分到其他的聚类中，X聚类被消除拆解，其他聚类中的站点信息被合理添加：

<img width="390" src="https://imgsa.baidu.com/forum/pic/item/c08f9858ccbf6c817a3e182db73eb13532fa40f3.jpg"/>

&emsp;&emsp;此外，Traffic聚类还可以解决距离过近的聚类可能会出现的问题，在上图中，由于两个聚类（B和C）的距离过近，在KMeans划分时很可能被划分为同一个聚类，因为这里的点比较密集。但是划分之后该聚类中的站点数量将会明显高于其他聚类中的站点数量，而经过Traffic聚类之后使用KMeans根据聚类内部的站点数量进行聚类时，就可以使得各个聚类内部的站点数量尽量趋于平均：
$$
某聚类的中心数量=期望的聚类中心总数\times\frac{该聚类中的站点数量}{站点总数}
$$

###### DBSCAN替换KMeans

&emsp;&emsp;尽管最后还是使用KMeans进行了聚类的实现，但是在一开始的构想中，笔者一直认为KMeans的聚类数量的选择过于主观。笔者与团队内的同学都相信使用DBSCAN聚类会更加适合该问题。

&emsp;&emsp;DBSCAN的主要思想是对各个站点的相邻站点进行比较，如果相邻的站点数量超过了阈值，则将当前的站点作为聚类中心，对应的集群站点作为聚类。从本质上看，该算法依然是根据经纬度进行聚类，但是较之于KMeans有如下几个优点：

1. 消除噪音点。

   DBSCAN选择的聚类中必须要有一定的站点数量，对于远离密集集群的噪音点集合，密度聚类根本不予考虑，密度聚类的衡量指标是密度而非距离。所以不会出现上图中的X聚类的情况。

2. 确定聚类数量。

   KMeans中确定聚类的数量是一件非常主观的事情，因为实验人员并不知道对于当前的数据集，多少个聚类才可以在避免噪音的情况下充分地表现当前的站点分布。而密度聚类则直接选择符合条件的聚类点，聚类的数量更加符合站点的地理分布特征，而不是主观地随意确定。

3. 符合实际分布。

   尽管站点的分布可能会有很多影响的因素，实际上的分布中还是要遵循不同的城市区域进行分布的，比如一个城市的城区内部站点分布会更加紧密，这种分布规律非常适合使用密度聚类。

&emsp;&emsp;但是，密度聚类也会有一些缺陷，密度聚类并不会将所有的点都纳入聚类中，也就是说，聚类结束后可能会存在某些站点不在聚类中，虽然这些站点也有流量，但是因为远离密集区域，故而被当做噪音点忽略掉了。对于这种情况可以使用KMeans进行补充聚类，处理被密度聚类当做噪音的少量站点，保证每一个站点都有归属的聚类。

##### GBRT模型与Adaboost模型

&emsp;&emsp;在该项目的实现过程中，笔者发现在建立GBRT模型的时候，为了训练出准确的可靠的模型，需要对模型针对训练集数据进行迭代训练。而GBRT的迭代训练是基于boost的迭代训练。

&emsp;&emsp;梯度树提升（Gradient Tree Boosting）是一种组合算法，也叫做梯度提升回归树（gradient boosting regression tree，GBRT），在原文中，GBRT的实现主要是针对具有不同属性的流量数据赋予权值，综合权值的数据对输出结果进行预测。

&emsp;&emsp;GBRT是boost算法的一个分支，boost是对参与计算的每一个样本赋予同样的权重，对每一个训练的样本同样重视。而adaboost中则是随着迭代过程中出现的预测错误信息，不断地增加错误分类数据的权重，也就是说，adaboost会筛选出每一次出现过错误的数据重复训练，增强其错误对于训练预测中结果的影响，这种训练方式，使得当前的模型可以更好地拟合出现过错误的数据。

#### 分工

- 曹广杰（15352015）

  分析整体流程，实验报告的撰写，交通聚类的实现，模块整合，具体算法的选择与修改；

- 蔡政（15352014）

  KMeans聚类的实现，时间似然函数，气温和风速似然函数的实现；

- 张明华（14353396）

  尚未实现天气似然函数的矩阵；

[^1]: https://github.com/AllLiving/Bicycle 